#!/usr/bin/perl -w
#
# Regina - A Normal Surface Theory Calculator
# Python Startup Script
#
# Copyright (c) 2002-2011, Ben Burton
# For further details contact Ben Burton (bab@debian.org).
#
# This script simply starts the Python interpreter and imports the Regina
# calculation engine, i.e., the module 'regina'.
#
# DO NOT EDIT THIS FILE DIRECTLY.  It has been automatically generated
# by configure and any changes will be overwritten.  Try editing
# regina-python.in instead.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

use strict;
use Cwd 'abs_path';
use File::Basename;

# --- Constants. ---

# The program name and directory.
my $prog_name = $0;
my $prog_dir = abs_path(dirname($prog_name));

# The module filename.
my $module_name = "regina.@REGINA_PYTHON_EXTENSION@";

# Address to which questions should be emailed.
my $regina_support = "regina-user\@lists.sourceforge.net";

# Default verbosity level.
my $default_verbosity = 1;

# Local configuration files.
my $home = $ENV{HOME};
if (! $home) {
    $home = `echo ~`;
}
my $python_conf = $home . "/.regina-python";
my $libs_conf = $home . "/.regina-libs";

# --- Variables. ---

my $quiet = 0;
my $verbose = 0;
my $interactive = 0;
my $autoImport = 1;
my $nolibs = 0;
my $regina_home = '';
my $runscript_py = '';
my $python_lib_dir = '';
my @python_libs;
my $script = '';
my @script_args;

# --- Parse the command-line options. ---

my $readingScriptArgs = 0;
foreach my $arg (@ARGV) {
    if ($readingScriptArgs) {
        push @script_args, $arg;
        next;
    }

    if ($arg eq '-q' or $arg eq '--quiet') {
        $quiet = 1;
        $verbose = 0;
        next;
    }

    if ($arg eq '-v' or $arg eq '--verbose') {
        $quiet = 0;
        $verbose = 1;
        next;
    }

    if ($arg eq '-i' or $arg eq '--interactive') {
        $interactive = 1;
        next;
    }

    if ($arg eq '-n' or $arg eq '--nolibs') {
        $nolibs = 1;
        next;
    }

    if ($arg eq '-a' or $arg eq '--noautoimport') {
        $autoImport = 0;
        next;
    }

    if ($arg =~ /^-/) {
        &usage("Unrecognised option: $arg");
    }

    # We must be onto the script.
    $script = $arg;
    $readingScriptArgs = 1;
}

if ($interactive and not $script) {
    &usage("The interactive option (-i, --interactive) can only be used with a script.");
}

# --- Determine the python executable.

# In the absence of any user-specified options, use the python
# command that corresponds to the original build environment.

my $python_cmd = "@PYTHON_EXECUTABLE@";
if (not -e $python_cmd) {
    &warn("W: The python command used during the build was: $python_cmd.\n");
    &warn("W: This command does not appear to be available now in the runtime environment.\n");
    $python_cmd = '';
}

# --- Determine the installation type.

my $install_type = "@REGINA_INSTALL_TYPE@";
if ( -f "$prog_dir/cmake_install.cmake" and -f "$prog_dir/../CMakeCache.txt") {
    $install_type = 'Source';
}

&info("I: Running from installation type: $install_type\n");

# --- Determine the underlying operating system.
my $os = "@CMAKE_SYSTEM_NAME@";
&info("I: Running on operating system: $os\n");

# --- Set up the environment.

# On OSX, python ships as a universal binary for several architectures.
# We need to make sure we are using the right one.
if (@OSX_PYTHON_32@) {
    $ENV{'VERSIONER_PYTHON_PREFER_32_BIT'} = 'yes';
}

# On Windows, we need to make sure all our DLLs are on the path.
if ($install_type eq 'Windows') {
    &extendEnvVar('PATH', $prog_dir);
}

# --- Extract variables from the configuration file.

if (open(CONF, $python_conf)) {
    my @lines = <CONF>;
    chomp @lines;
    close(CONF);

    foreach my $line (@lines) {
        if ($line =~ /^\s*$/ or $line =~ /^\s*#/) {
            next;
        }
        if ($line =~ /^\s*([A-Za-z_]+)\s*=\s*$/) {
            &warn("W: Variable $1 is not assigned a value in $python_conf.\n");
            next;
        }
        if ($line =~ /^\s*([A-Za-z_]+)\s*=\s*(\S(.*\S)?)\s*$/) {
            # We have a configuration variable.
            if ($1 eq 'REGINA_VERBOSITY') {
                &setVerbosity($2);
            } elsif ($1 eq 'REGINA_PYTHON') {
                &setPythonCmd($2);
            } elsif ($1 eq 'REGINA_PYLIBDIR') {
                &setPythonLibDir($2);
            } elsif ($1 eq 'REGINA_HOME') {
                &setReginaHome($2);
            } else {
                &warn("W: Unknown variable $1 in $python_conf.\n");
            }
            next;
        }
        &warn("W: Bad line in $python_conf:\n$line\n");
    }
}

# --- Extract variables from the environment. ---

if ($ENV{REGINA_VERBOSITY}) {
    &setVerbosity($ENV{REGINA_VERBOSITY});
}
if ($ENV{REGINA_HOME}) {
    &setReginaHome($ENV{REGINA_HOME});
}
if ($ENV{REGINA_PYTHON}) {
    &setPythonCmd($ENV{REGINA_PYTHON});
}
if ($ENV{REGINA_PYLIBDIR}) {
    &setPythonLibDir($ENV{REGINA_PYLIBDIR});
}

# --- Check that the current options are reasonable. ---

my $prefix = "@CMAKE_INSTALL_PREFIX@";
my $exec_prefix = "@CMAKE_INSTALL_PREFIX@";
my $pkgdatadir = "@PKGDATADIR@";
my $libdir = "@LIBDIR@";
my $package = "@PACKAGE_NAME@";

if (! $regina_home) {
    if ($install_type eq 'Source') {
        # Setting $regina_home is interesting, because we want things
        # from both the builddir and the srcdir.  Use both.
        my $builddir = "$prog_dir/..";
        my $srcdir = "@CMAKE_SOURCE_DIR@";
        $srcdir =~ /^\// or                  # Unix-style absolute path
            $srcdir =~ /^[A-Za-z]:[\\\/]/ or # Windows-style absolute path
            $srcdir = "$prog_dir/$srcdir";   # Relative path: make absolute

        &setReginaHome($builddir, $srcdir);
    } elsif ($install_type eq 'Bundle') {
        &setReginaHome("$prog_dir/../Resources");
    } else {
        &setReginaHome($pkgdatadir);
    }
}

if (! $python_cmd) {
    my $which_python;
    chomp($which_python = `which python`);
    if (! $which_python) {
        &err("E: A Python interpreter could not be found.\n");
        &err("E: Set \$REGINA_PYTHON to a Python interpreter (such as /usr/bin/python)\n");
        &err("E: and try again.\n");
        exit 1;
    }
    &setPythonCmd($which_python);
}

if (! $python_lib_dir) {
    if ($install_type eq 'Bundle') {
        &setPythonLibDir("$prog_dir/python");
    } elsif ($install_type eq 'Source') {
        &setPythonLibDir("$regina_home/python");
    } else {
        &setPythonLibDir("$libdir/$package/python");
    }
}

# --- Find the default charset to use for filename encodings. ---

my $codeset = undef;
eval {
    require I18N::Langinfo;
    $codeset = I18N::Langinfo::langinfo(I18N::Langinfo::CODESET());
};
if (not defined $codeset) {
    if ($os ne 'Windows') {
        &warn("W: Could not determine default character encoding for filenames.\n");
        &warn("W: Try setting \$LANG if this is causing problems.\n");
    } else {
        # We can't help this under Windows; drop the severity.
        &info("I: Could not determine default character encoding for filenames.\n");
        &info("I: Try setting \$LANG if this is causing problems.\n");
    }
}

# --- Read the list of libraries to load. ---

if ($nolibs) {
    &info("I: Not loading user libraries, as requested on the command-line.\n");
} elsif (open(LIBS, $libs_conf)) {
    my @lines = <LIBS>;
    chomp @lines;
    close(LIBS);

    my $lib;
    foreach my $line (@lines) {
        if ($line =~ /^\s*#/) {
            next;
        }
        if ($line =~ /^\s*(\S(.*\S)?)\s*$/) {
            # Treat this as a library file.
            $lib = $1;

            # Libraries are stored in UTF-8; convert to a local encoding
            # if we know how.
            if (defined $codeset) {
                if (not defined eval {
                    require Encode;
                    Encode::from_to($lib = $1, 'utf8', $codeset);
                }) {
                    &warn("W: Could not convert filename $1 from UTF-8 to $codeset.\n");
                    $lib = $1;
                }
            }
            if (-e $lib) {
                &info("I: Adding library $lib.\n");
                push @python_libs, $lib;
            } else {
                &err("E: Python library $lib does not exist (found in $libs_conf).\n");
            }
        }
    }
}

# --- Go ahead and run the application. ---

&extendEnvVar('PYTHONPATH', $python_lib_dir);

if ($install_type eq 'Source') {
    # Since we're running from the source tree, we need to ensure that
    # the calculation engine library can be found.
    if ($os eq 'Darwin') {
        &extendEnvVar('DYLD_LIBRARY_PATH', "$regina_home/engine/");
    } elsif ($os eq 'Windows') {
        &extendEnvVar('PATH', "$regina_home/engine/");
    } else {
        &extendEnvVar('LD_LIBRARY_PATH', "$regina_home/engine/");
    }
} elsif ($install_type eq 'Bundle') {
    # Make sure we can find the libraries shipped with the bundle.
    &extendEnvVar('DYLD_LIBRARY_PATH', $prog_dir);
} elsif ($install_type eq 'Windows') {
    # Make sure we can find the libraries shipped with the application.
    &extendEnvVar('PATH', $prog_dir);
}

my @fullCommandLine = ( $python_cmd );

if ($script) {
    if (! -e $script) {
        &usage("E: The script $script could not be found.");
    }
    my @fullCommandLine = ( $python_cmd );
    $interactive and push @fullCommandLine, '-i';
    push @fullCommandLine, $runscript_py;
    push @fullCommandLine, ($autoImport ? 'import' : 'noimport');
    push @fullCommandLine, @python_libs;
    push @fullCommandLine, ( '--', $script );
    push @fullCommandLine, @script_args;
    exec @fullCommandLine or &execError();
} else {
    my @fullCommandLine = ( $python_cmd, '-i', $runscript_py );
    push @fullCommandLine, ($autoImport ? 'import' : 'noimport');
    push @fullCommandLine, @python_libs;
    exec @fullCommandLine or &execError();
}

# --- Helper routines. ---

# Set various configuration options.
#
sub setVerbosity() {
    &info("I: Setting verbosity to $_[0].\n");
    if ($_[0] eq '0') {
        $quiet = 1;
        $verbose = 0;
    } elsif ($_[0] eq '1') {
        $quiet = 0;
        $verbose = 0;
    } elsif ($_[0] eq '2') {
        $quiet = 0;
        $verbose = 1;
    } else {
        &err("E: The verbosity level $_[0] is not recognised.\n");
        &err("E: This should be 0 (errors), 1 (errors/warnings) or 2 (everything).\n");
    }
}
sub setPythonCmd() {
    &info("I: Setting python command to $_[0].\n");
    $python_cmd = $_[0];
}
sub setPythonLibDir() {
    &info("I: Setting python module directory to $_[0].\n");
    if ( ! -e "$_[0]/$module_name") {
        &err("E: The calculation engine module '$module_name' could not be \n");
        &err("   found in the directory $_[0].\n");
        &err("E: Please set \$REGINA_PYLIBDIR to the directory containing\n");
        &err("   the module '$module_name' and try again.\n");
        exit 1;
    }
    $python_lib_dir = $_[0];
}
sub setReginaHome() {
    # Set both $regina_home and $runscript_py.
    if (defined $_[1]) {
        # Interpret the two arguments as a "binary" home and a "source" home.
        # This makes sense when running out of the source tree.
        &info("I: Setting Regina home directories to ($_[0], $_[1]).\n");
        $regina_home = $_[0];
        $runscript_py = "$_[1]/python/runscript.py";
    } else {
        # Interpret the single argument as a traditional REGINA_HOME.
        # This makes sense when running out of a standard installation.
        &info("I: Setting Regina home directory to $_[0].\n");
        $regina_home = $_[0];
        $runscript_py = "$_[0]/internal/scripts/runscript.py";
    }

    # Sanity test.
    if ( ! -e $runscript_py) {
        &err("E: \$REGINA_HOME should be set to the Regina base directory.\n");
        &err("   This is the directory containing the 'scripts' subdirectory,\n");
        &err("   the 'icons' subdirectory and so on.\n");
        &err("E: It is currently set to $regina_home .\n");
        exit 1;
    }
}
sub extendEnvVar() {
    &info("I: Appending $_[1] to \$$_[0].\n");
    if ($ENV{$_[0]}) {
        $ENV{$_[0]} = "$_[1]:$ENV{$_[0]}";
    } else {
        $ENV{$_[0]} = $_[1];
    }
}

# Write the given message to stderr if verbose mode is on.
#
sub info {
    if ($verbose) {
        print STDERR $_[0];
    }
}
# Write the given message to stderr if quiet mode is off.
#
sub warn {
    if (! $quiet) {
        print STDERR $_[0];
    }
}

# Write the given message to stderr.
#
sub err {
    print STDERR $_[0];
}

# Display usage information and exit.
#
sub usage {
    my $msg = shift;
    defined($msg) and print STDERR "$msg\n\n";
    print STDERR "Usage: 1. $prog_name\n";
    print STDERR "               [ -q, --quiet | -v, --verbose ]\n";
    print STDERR "               [ -n --nolibs ] [ -a, --noautoimport] \n";
    print STDERR "       2. $prog_name\n";
    print STDERR "               [ -q, --quiet | -v, --verbose ]\n";
    print STDERR "               [ -n --nolibs ] [ -a, --noautoimport] \n";
    print STDERR "               [ -i, --interactive ] script [ script_args ... ]\n";
    exit 1;
}

# The python interpreter could not be started.
#
sub execError() {
    &err("E: An error occurred whilst trying to start the Python interpreter.\n");
    &err("E: Run '$prog_name --verbose' to see more detailed diagnostic output,\n");
    &err("   including the runtime options being used.\n");
    &err("E: If you still cannot resolve the problem, please mail\n");
    &err("   $regina_support for assistance.\n");
}

