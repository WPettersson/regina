<chapter id="foreign">
 <title>Importing and Exporting Data</title>

 <para>
  By default, &regina; reads and writes
  <filename>.rga</filename> data files in its own compressed
  &xml; file format.
  However, &regina; can also import data from and export data to several
  other file formats, which allows you to pass data between &regina; and
  other applications.
  This chapter outlines the available import and export formats.
 </para>
 <para>
  If you are writing filters for some other program and you need a full
  specification for &regina;'s own &xml; file format, select
  <menuchoice>
   <guimenu>Help</guimenu>
   <guisubmenu>File Format Reference</guisubmenu>
  </menuchoice> from the menu.
 </para>

 <sect1 id="foreign-import">
  <title>Importing</title>

  <para>
   An <firstterm>import</firstterm> involves reading data from some
   foreign file format and inserting it into your working packet tree
   (effectively merging it into whatever file you already have open).
   All imports are done through the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Import</guisubmenu>
   </menuchoice>
   menu.
  </para>
  <para>
   <inlinemediaobject>
    <imageobject>
     <imagedata fileref="menu-import.png"/>
    </imageobject>
   </inlinemediaobject>
  </para>
  <para>
   The
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Import</guisubmenu>
   </menuchoice>
   menu will <emphasis>only appear once you have a file open</emphasis>.
   If you have just started up &regina;, you will first need to create a
   new file by selecting
   <menuchoice>
    <guimenu>File</guimenu>
    <guimenuitem>New Topology Data</guimenuitem>
   </menuchoice>
   (or pressing the corresponding toolbar button).
  </para>
  <para>
   When you select an action from the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Import</guisubmenu>
   </menuchoice>
   menu, you will first be asked to select a file.
   Once you have chosen the file to import, a second window will appear
   asking for additional details:
  </para>
  <para>
   <inlinemediaobject>
    <imageobject>
     <imagedata fileref="import-snappea.png"/>
    </imageobject>
   </inlinemediaobject>
  </para>
  <para>
   <glosslist>
    <glossentry>
     <glossterm><guilabel>Import beneath:</guilabel></glossterm>
     <glossdef><para>
      Here you select where in the packet tree the imported data will appear.
      The import will be added as a new packet, immediately beneath
      whatever &ldquo;parent&rdquo; packet you choose here.
     </para></glossdef>
    </glossentry>
    <glossentry id="import-label">
     <glossterm><guilabel>Label:</guilabel></glossterm>
     <glossdef><para>
      This will be the label (i.e., the name) of the new packet containing
      the imported data.
      No two packets in the same data file may have the same label.
     </para></glossdef>
    </glossentry>
   </glosslist>
  </para>
  <para>
   &regina; can import data from the following file formats:
  </para>

  <sect2 id="import-regina">
   <title>&regina; Data Files</title>

   <para>
    You can import another &regina; data file.
    This effectively lets you insert the contents of one file inside another.
   </para>
   <para>
    This is a convenient way of merging two data files into one.
    You can also merge data files from the command-line using the
    <link linkend="man-regconcat"><command>regconcat</command></link>
    utility.
   </para>
  </sect2>

  <sect2 id="import-snappea">
   <title>&snappea; Triangulations</title>

   <para>
    You can import a triangulation from &snappea;.
    &snappea; is the excellent software written by Jeffrey Weeks
    for studying hyperbolic 3-manifolds;
    for more information on &snappea; and its successor &snappy;,
    see the &snappywebsite;.
    Note that you can also perform some &snappea; calculations
    <link linkend="tri-snappea">directly within &regina;</link>.
   </para>
   <para>
    The file that you import should be a plain text file in
    &snappea;'s triangulation format; an example is shown below.
    Any international characters should be encoded in &utf8;.
   </para>
   <programlisting>
    % Triangulation
    m002
    geometric_solution  2.02988321
    nonorientable_manifold
    CS_unknown

    0 2
        Klein   0.000000000000   0.000000000000
        Klein   0.000000000000   0.000000000000

    2
       1    1    1    1
     0132 3120 2130 3102
       0    1    0    0
      0  0  0  0  0  0  1 -1  0  0  0  0  1 -1  0  0
      0  1 -1  0  0  0  0  0 -1  0  0  1  0  0  0  0
      0  0  1 -1 -1  0  1  0  1  0  0 -1 -1  1  0  0
      0  0  1 -1 -1  0  1  0  1  0  0 -1 -1  1  0  0
      0.500000000000   0.866025403784

       0    0    0    0
     0132 3120 2130 3102
       0    1    0    0
      0  1 -1  0  0  0  0  0 -1  0  0  1  0  0  0  0
      0  0  0  0  0  0  1 -1  0  0  0  0  1 -1  0  0
      0 -1  1  0  1  0  0 -1  1  0  0 -1 -1  0  1  0
      0 -1  1  0  1  0  0 -1  1  0  0 -1 -1  0  1  0
      0.500000000000   0.866025403784
   </programlisting>
  </sect2>

  <sect2 id="import-orb">
   <title>&orbcasson; Triangulations</title>

   <para>
    You can import a triangulation from &orbcasson; format.
    &orburl; is a variant of &snappea; for calculating hyperbolic
    structures on 3-orbifolds and 3-manifolds, written by Damien Heard.
   </para>
   <para>
    The file that you import
    should be a plain text file in &orbcasson; format, which
    describes a triangulation in terms of its 1-skeleton.  The beginning
    of an example file is illustrated below.
    Any international characters should be encoded in &utf8;.
   </para>
   <programlisting>
    % orb
    8knot
    1  0  1.000  1vu  2uw  1ux  2xv  1xw  2vu
    2  0  1.000  1wu  2wx  1xv  2xu  1vw  2vw

    ...
   </programlisting>
  </sect2>

  <sect2 id="import-isosiglist">
   <title>Isomorphism Signature Lists</title>

   <para>
    You can import a list of isomorphism signatures from a text file.
    This is a space-efficient, plain-text method of storing a list
    of 3-manifold triangulations.
   </para>
   <para>
    An <firstterm>isomorphism signature</firstterm> is a
    compact sequence of letters, digits and/or punctuation that identifies a
    triangulation uniquely up to combinatorial isomorphism.
    See the <link linkend="tri-composition-isosig">composition viewer</link>
    for a more detailed discussion on isomorphism signatures, or
    <xref linkend="bib-burton-pachner-orprime"/> for examples of their use
    and a precise description of the signature format.
   </para>
   <para>
    The list should be stored in a plain text file with one triangulation
    per line.  Each line may contain an arbitrary amount of data, but the
    first word of each line should be the isomorphism signature.
    Note that isomorphism signatures are <emphasis>case sensitive</emphasis>
    (i.e., upper-case and lower-case matter).  An example file is shown below.
   </para>
   <programlisting>
    dLQbcbchxjn   L(11,3)
    dLQbcbchxjj   L(10,3)
    dLQbcbcahrs   L(5,2)
    dLQbcbcahks   S3
    dLQbcbchhjw   L(9,2)
   </programlisting>
   <para>
    The import will appear in your packet tree as a new
    <link linkend="packet-container">container</link>,
    which will contain a new triangulation for each isomorphism signature
    in the list.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="import-isosig.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
   <para>
    If you just wish to reconstruct a triangulation from a single
    isomorphism signature (not from many signatures), you can do this
    more easily by creating a
    <link linkend="tri-new-isosig">new triangulation</link>.
   </para>
  </sect2>

  <sect2 id="import-dehydrationlist">
   <title>Dehydrated Triangulation Lists</title>

   <para>
    You can import a list of dehydration strings from a text file.
    Like <link linkend="import-isosiglist">isomorphism signatures</link>,
    dehydration strings allow you to encode a list of triangulations in
    a space-efficient, plain-text manner.
   </para>
   <para>
    Dehydration strings are
    <link linkend="tri-composition-dehydration">less powerful</link>
    than isomorphism signatures.  They feature in hyperbolic census papers
    such as <xref linkend="bib-cuspedcensus"/>,
    in which the dehydration format is explicitly described.
   </para>
   <para>
    The list should be stored in a plain text file with one triangulation
    per line.  Each line may contain an arbitrary amount of data, but the
    first word of each line should be the dehydration
    string.  An example file is shown below.
   </para>
   <programlisting>
    dafbcccaadl   N3,1   Z/3 + Z
    dadcbccdjkd   N3,2   Z
    dadbcccbbcv   N3,3   Z
    dadbcccccdm   N3,4   Z
    dadbcccaqhx   N3,5   Z/2 + Z/2 + Z
   </programlisting>
   <para>
    As with isomorphism signatures,
    the import will appear in your packet tree as a new
    <link linkend="packet-container">container</link>,
    which will contain a new triangulation for each dehydration string
    in the list.
   </para>
   <para>
    If you just wish to reconstruct a triangulation from a single
    dehydration string (not from many strings), you can do this
    more easily by creating a
    <link linkend="tri-new-dehydration">new triangulation</link>.
   </para>
  </sect2>

  <sect2 id="import-pdf">
   <title>&pdf; Documents</title>

   <para>
    You can import a &pdf; document, which will appear in your data file
    as a <link linkend="packet-pdf">&pdf; packet</link>.
    This you to document your work with formulae, diagrams and
    anything else that can appear on the printed page.
   </para>
   <para>
    This is the only way of creating a &pdf; packet within &regina;.
    If you select
    <menuchoice>
     <guimenu>Packet Tree</guimenu>
     <guimenuitem>New PDF Document</guimenuitem>
    </menuchoice>
    from the menu, &regina; will go through exactly the same import
    process as described here.
   </para>
  </sect2>

  <sect2 id="import-pyscript">
   <title>&python; Scripts</title>

   <para>
    You can import a &python; script, which will appear in your data
    file as a <link linkend="python-script">script packet</link>.
   </para>
   <para>
    Script packets can include pre-set <emphasis>variables</emphasis>
    that reference other packets in your data file.
    If the imported file begins with a specially
    formatted comment block, &regina; will recognise this and set
    variables in your script packet accordingly.
    This comment block will be written automatically when you
    <link linkend="export-pyscript">export a script packet</link>
    to a &python; file.
    The special comment block is used only for setting variables, and will
    not appear in the code for your new script packet.
   </para>
   <para>
    An example of such a comment block appears below.
   </para>
   <programlisting>
    ### Regina Script: Homology Summary
    ###
    ### Variable tri: Triangulations
    ###
    ### Begin Script

    # See the users' handbook for more elaborate sample Python
    # sessions.

    # Output the homology of each triangulation.
    t = tri.getFirstTreeChild()
    while t != None:
        print t.getPacketLabel() + ":", t.getHomologyH1()
        t = t.getNextTreeSibling()
   </programlisting>
   <para>
    The comment block must appear at the very beginning
    of the file, and each line must begin with three hashes
    (<literal>###</literal>).  A line of the form
    &ldquo;<literal>###&nbsp;Regina&nbsp;Script:&nbsp;<replaceable>label</replaceable></literal>&rdquo;
    suggests to &regina; a <link linkend="import-label">default label</link>
    for your new packet.
    Each line of the form
    &ldquo;<literal>###&nbsp;Variable&nbsp;<replaceable>name</replaceable>:&nbsp;<replaceable>value</replaceable></literal>&rdquo;
    tells &regina; to add the variable <replaceable>name</replaceable>
    to the new script packet, and to make it refer to the packet
    in your data file named <replaceable>value</replaceable>.
   </para>
   <para id="encodings">
    During the import, &regina; will tell you how it will interpret any
    international characters in the script (that is, letters or symbols
    not found on a typical English keyboard).  Such characters are
    stored using a <firstterm>text encoding</firstterm>, such as
    &utf8; (a popular modern standard and the default in &regina;),
    or &latin1; (which has a long history of use with many Western European
    languages).
    If your script uses a different encoding, you will need to set this
    in <link linkend="options-encoding">&regina;'s options</link>.
    If you only ever use letters or symbols on a typical English keyboard,
    you do not need to worry about this at all.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="i18n-import.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
  </sect2>
 </sect1>

 <sect1 id="foreign-export">
  <title>Exporting</title>

  <para>
   An <firstterm>export</firstterm> involves writing data from your
   working packet tree into some foreign file format.
   For most formats you can only export small pieces of your packet tree
   at a time (such as individual triangulations).
   All exports are done through the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Export</guisubmenu>
   </menuchoice>
   menu.
  </para>
  <para>
   <inlinemediaobject>
    <imageobject>
     <imagedata fileref="menu-export.png"/>
    </imageobject>
   </inlinemediaobject>
  </para>
  <para>
   When you select an action from the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Export</guisubmenu>
   </menuchoice>
   menu, &regina; will ask you which packet to export.
   For most export formats &regina; will only export the selected packet,
   but for some formats (such as
   <link linkend="export-rga">&regina;'s own data format</link>)
   it will export an entire packet subtree.
  </para>
  <para>
   <inlinemediaobject>
    <imageobject>
     <imagedata fileref="export-snappea.png"/>
    </imageobject>
   </inlinemediaobject>
  </para>
  <para>
   After selecting a packet, you will
   be asked to choose a filename for your export.
   &regina; will then save the exported data to that file.
  </para>
  <para>
   &regina; can export data to the following file formats:
  </para>

  <sect2 id="export-rga">
   <title>&regina; Data Files</title>

   <para>
    This is &regina;'s native file format, in which data is saved as
    compressed &xml;.
    &regina; can export an entire packet subtree to this format:
    just choose the root of of the subtree as the packet to export.
    &regina; will export not just the packet you select, but all of the
    packets beneath it in the tree.
   </para>
   <para>
    This is a convenient way of extracting a small portion from
    a larger data file.
   </para>
   <para>
    The packet that you select for export will become the top-level
    packet in the new tree (i.e., &regina; will not add a new
    <link linkend="packet-container">container</link>
    to the top of the export data file).
   </para>
   <para>
    There are two menu items for exporting to a &regina; data
    file.  If you choose
    <menuchoice>
     <guimenu>File</guimenu>
     <guisubmenu>Export</guisubmenu>
     <guimenuitem>&regina; Data File</guimenuitem>
    </menuchoice>,
    the data will be exported as compressed &xml; (the standard
    file format).  If you choose
    <menuchoice>
     <guimenu>File</guimenu>
     <guisubmenu>Export</guisubmenu>
     <guimenuitem>&regina; Data File (Uncompressed)</guimenuitem>
    </menuchoice>,
    the data will be saved as plain &xml; (which means you
    can view the &xml; in your favourite text editor).
    &regina; is capable of reading data files in either compressed or
    uncompressed format.
   </para>
   <para>
    If you simply want to view the raw &xml; content of an existing data
    file, you do not need to go to the trouble of exporting
    it in uncompressed format.
    Instead you can just pipe the data file through
    <command>gunzip</command>:
   </para>
<screen>
    <prompt>example$</prompt> <userinput>cat file.rga | gunzip</userinput>
</screen>
  </sect2>

  <sect2 id="export-snappea">
   <title>&snappea; Triangulations</title>

   <para>
    You can export a triangulation to &snappea;'s
    native file format.  This is a plain text format,
    described in more detail in the section on
    <link linkend="import-snappea">&snappea; imports</link>.
   </para>
   <para>
    Not every data file can be exported to &snappea; format.
    For instance, the triangulation cannot be
    <link linkend="tri-propvalid">invalid</link>,
    and it may not have any boundary faces.
    &regina; will tell you if your triangulation cannot be exported.
   </para>
   <para>
    Any international characters in the exported &snappea; file will be
    encoded using &utf8;.
   </para>
  </sect2>

  <sect2 id="export-recogniser">
   <title>&recogniser; Triangulations</title>

   <para>
    You can export a triangulation to a plain text file that can be
    given as input to Matveev's &recogniserlink;.
   </para>
   <para>
    As with the &snappea; format, not every data file can be exported to
    the &recogniser;.
    In particular, the triangulation cannot be
    <link linkend="tri-propvalid">invalid</link>,
    and it may not have any boundary faces.
    &regina; will tell you if your triangulation cannot be exported.
   </para>
  </sect2>

  <sect2 id="export-cpp">
   <title>&cpp; Source Code</title>

   <para>
    You can export a triangulation as &cpp; source code.
    This &cpp; code will use classes and routines from
    &regina;'s calculation engine.  When run, this code will reconstruct
    your triangulation.
   </para>
   <para>
    Exporting to &cpp; can be useful if you wish to hard-code a
    triangulation in your own &cpp; project.
    See the separate chapter on
    <link linkend="compiling">building &regina; into your own code</link>.
   </para>
   <para>
    During the export, &regina; will tell you how it will write any
    international characters (that is, letters or symbols
    not found on a typical English keyboard).  Such characters are
    stored using a <firstterm>text encoding</firstterm>, such as
    &utf8; (a popular modern standard and the default in &regina;),
    or &latin1; (which has a long history of use with many Western European
    languages).
    If you wish to use a different encoding, you will need to set this
    in <link linkend="options-encoding">&regina;'s options</link>.
    If you are not sure, the default of &utf8; is typically a good choice.
    If you only ever use letters or symbols on a typical English keyboard,
    you do not need to worry about text encodings at all.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="i18n-export.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
  </sect2>

  <sect2 id="export-csvsurfacelist">
   <title>Spreadsheet-Readable (&csv;) Surface Lists</title>

   <para>
    You can export a normal surface list to a plain-text
    &csv; file (comma-separated values), which you can easily
    import into a spreadsheet or database.
   </para>
   <para>
    The &csv; file will begin with a header row, followed
    by one line for each normal surface in the list.  Surfaces will be
    exported in standard coordinates
    (that is, <link linkend="surfaces-defstandard">tri-quad coordinates</link>
    for normal surfaces, or
    <link linkend="surfaces-defstandardan">tri-quad-oct coordinates</link>
    for almost normal surfaces).
    The fields in the &csv; file will mirror the columns that you see
    in the <link linkend="surfaces-coords">normal surface
    coordinate viewer</link>, and will include properties such as
    Euler characteristic and orientability as well as the
    surface coordinates themselves.
   </para>
   <para>
    If any of the surfaces have names that include
    international characters, these names will be exported in &utf8;.
   </para>
  </sect2>

  <sect2 id="export-pdf">
   <title>&pdf; Documents</title>

   <para>
    You can export a &pdf; packet to an ordinary &pdf; document.
   </para>
   <para>
    If you simply wish to view &pdf; packets in a different viewer,
    you do not need to go to the trouble of exporting the
    packet&mdash;instead you can
    <link linkend="options-tools">configure &regina;</link> to use your
    favourite viewer by default.
   </para>
  </sect2>

  <sect2 id="export-pyscript">
   <title>&python; Scripts</title>

   <para>
    You can export a <link linkend="python-script">script packet</link>
    as a regular &python; file.
    &regina; will add a special comment block to the top of the file,
    describing the packet label and the script variables.
    This special comment block allows you to import the script
    seamlessly back into &regina;; see
    <link linkend="import-pyscript">&python; imports</link> for details.
   </para>
   <para>
    During the export, &regina; will tell you how it will encode any
    international characters in the script (i.e., letters or symbols
    not found on a typical English keyboard).
    See the <link linkend="export-cpp">&cpp; exports</link> section
    above for more information on text encodings.
   </para>
  </sect2>
 </sect1>
</chapter>
